---
export_on_save:
 html: true
---

# ch2. 计算机网络和因特网

[toc]

- 网络应用是计算机网络存在的理由，因特网应用包括
  - 基于文本的应用
    - 文本电子邮件
    - 远程访问计算机
    - 文件传输
    - 新闻组
  - 万维网
    - Web冲浪
    - 搜索
    - 电子商务
  - 新的应用
    - IP电话（VoIP
    - IP视频会议（如Skype
    - 用户生成 的视频分布（如YouTube
    - 点播电影（如Netflix）
    - 多方在线游戏
    - 新一代的社交网络
      - Facebook
      - Instagram
      - Twitter
      - 微信

## 2.1 应用层协议

- 研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序
  - 由于网络的分层设计，因此开发网络应用程序时，不需要写在网络核心设备如路由器或链路层交换机上运行的软件
  - 分层设计，即将应用软件限制在端系统的方法，促进了大量的网络应用程序的迅速研发和部署
  - ![网络应用的通信](images/2020-07-17-12-32-33.png)

### 2.1.1 网络应用程序体系结构

- 从应用程序研发者的角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合
- 应用程序体系结构（application architecture）由应用程序研发者设计, 规定了如何在各种端系统上组织该应用程序
  - 两种主流体系结构
    - 客户-服务器体系结构
      - ![客户-服务器体系结构](images/2020-07-17-12-36-08.png)
      - 特点
        - 有一个总是打开的主机称为**服务器**，它服务于来自许多其他称为**客户**的主机的请求
        - 利用客户-服务器体系结构，客户相互之间不直接通信
        - 服务器具有固定的、周知的地址，该地址称为IP地址
      - 应用程序
        - Web、 FTP、Telnet和电子邮件
      - 问题
        - 常常会出现一台单独的服务器主机跟不上它所有客户请求的情况
        - 为此，配备大量主机的**数据中心**常被用于创建强大的虚拟服务器
          - 一个数据中心能够有数十万台服务器，它们必须要供电和维护
          - 服务提供商必须支付不断出现的互联和带宽费用，以发送和接收到达/来自数据中心的数据
    - 对等（P2P）体系结构
      - ![P2P 体系结构](images/2020-07-17-12-36-52.png)
      - 特点
        - 对位于数据中心的专用服务器有最小的（或者没有）依赖
        - 应用程序在间断连接的主机对之间使用直接通信
          - 这些主机对被称为对等方
        - 这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的
        - 自扩展性（self-scalability）
          - 在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量
          - 但每个对等方 通过向其他对等方分发文件也为系统增加服务能力
        - P2P体系结构也是成本有效的
          - 它们通常不需要庞大的服务器基础设施和服务器带宽
      - 应用程序
        - 许多目前流行的、流量密集型应用都是P2P体系结构的
        - 文件共享（例如BitTorrent）
        - 对等方协助下载加速器（例如迅雷）
        - 因特网电话（例如Skype）

### 2.1.2 进程通信

- 在操作系统的术语中，进行通信的实际上是进程（process）而不是程序
  - 当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信
    - 进程间通信的规则由端系统上的操作系统确定
  - 在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信

#### 客户和服务器进程

- 网络应用程序由成对的进程组成，这些进程通过网络相互发送报文
- 对每对通信进程，我们通常将这两个进程之一标识为客户（client）,而另一个进程标识为服务器（server）
  - 在给定的一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为**客户**，在会话开始时等待联系的进程是**服务器**

#### 进程与计算机网络之间的接口

- 进程通过一个称为**套接字**（socket）的软件接口向网络发送报文和从网络接收报文
- 套接字
  - ![套接字](images/2020-07-17-12-53-10.png)
  - 套接字是同一台主机内应用层与运输层之间的接口
  - 套接字也称为应用程序和网络之间的应用程序编程接口（Application Programming Interface, API）
  - 应用程序开发者对于运输层的控制仅限于：
    - 选择运输层协议
    - 设定几个运输层参数，如最大缓存和最大报文段长度等

#### 进程寻址

- 为了标识接收进程，需要定义两种信息
  - 主机的地址
    - 主机由其IP地址（IP address）标识
  - 定义在目的主机中的接收进程的标识符
    - 目的地**端口号**（port number）用于指定运行在接收主机上的接收进程
    - 流行的应用已被分配了特定的端口号
      - Web服务器用端口号80来标识
      - 邮件服务器进程（使用SMTP 协议）用端口号25来标识

### 2.1.4 可供应用程序使用的运输服务

- 包括因特网在内的很多网络提供了不止一种运输层协议
  - 当开发一个应用时，必须选择一种可用的运输层协议
  - 需要根据实际的应用需求来选择恰当的服务协议

- 应用程序要求运输层协议能提供的服务大体包括四个方面：可靠数据传输、吞吐量、定时和安全性

#### 可靠数据传输

- 如果一个协议提供了确保数据交付服务，就认为提供了可靠数据传输(reliable data transfer)
  - 确保数据交付服务是指确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端
- 容忍丢失的应用(loss-tolerant application)
  - 当一个运输层协议不提供可靠数据传输时, 可能能被容忍丢失的应用所接受
  - 在多媒体应用中，能够承受一定量的数据丢失
    - 丢失的数据引起播放的音频/视频出现小干扰，而不是致命的损伤

#### 吞吐量

- 可用吐吞量
  - 在沿着一条网络路径上的两个进程之间的通信会话场景中，可用吞吐量就是发送进程能够向接收进程交付比特的速率
- 运输层协议能够以某种特定的速率提供确保的可用吞吐量

- 具有吞吐量要求的应用程序被称为**带宽敏感的应用**(bandwidth-sensitive application) 
  - 许多当前的多媒体应用是带宽敏感的

- **弹性应用**(elastic application)
  - 能够根据情况或多或少地利用可供使用的吞吐量
  - 电子邮件、文件传输以及 Web 传送都属于弹性应用

#### 定时

- 运输层协议也能提供定时保证
  - 如发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms
  - 对交互式实时应用程序有吸引力
    - 如因特网电话、虚拟环境、电话会议和多方游戏
    - 所有这些服务为了有效性而要求数据交付有严格的时间限制

#### 安全性

- 运输协议能够为应用程序提供一种或多种安全性服务
  - 提供数据的加密和解密功能
  - 数据完整性和端点鉴别

### 2.1.4 因特网提供的运输服务

- 因特网（更一般的是TCP/IP网络）为应用程序 提供两个运输层协议，即UDP和TCP
- 某些网络应用的相求

| 应用         | 数据丢失 | 带宽                                       | 时间敏感    |         |
|------------|------|------------------------------------------|---------|---------|
| 文件传输       | 不能丢失 | 弹性                                       | 不       |         |
| 电子邮件       | 不能丢失 | 弹性                                       | 不       | 不       |
| Web文档      | 不能丢失 | 弹性（几kbps）                                | 不       | 不       |
| 因特网电话/视频会议 | 容忍丢失 | 音频(几 kbps ~ 1 Mbps)，视频(10 kbps ~ 5 Mbps) | 是，100ms |
| 存储音频/视频    | 容忍丢失 | 同上                                       | 是，几秒    | 是.几秒    |
| 交互式游戏      | 容忍丢失 | 几 kbps ~ 10 kbps                         | 是，100ms | 是，100ms |
| 智能手机讯息     | 不能丢失 | 弹性                                       | 是和不是    | 是和不是    |

#### TCP 服务

- TCP服务模型包括面向连接服务和可靠数据传输服务
  - 面向连接的服务
    - 在握手阶段后，一个TCP连接（TCP connection）就在两个进程的套接字之间建立了
    - 这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发
    - 当应用程序结束报文发送时，必须拆除该连接
  - 可靠的数据传输
    - 通信进程能够依靠TCP,无差错、按适当顺序交付所有发送的数据
    - 没有字节的丢失和冗余
- TCP协议还具有拥塞控制机制，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处
- TCP 安全
  - 无论TCP还是UDP都没有提供任何加密机制
  - 因特网界已经研制了 TCP的加强版本，称为安全套接字层（Secure Sockets Layer, SSL）
    - 用 SSL 加强后的 TCP 不仅能够做传统的 TCP 所能做的一切，而且提供了关键的进程到进程的安全性服务
      - 包括加密、数据完整性和端点鉴别
    - SSL 是一种对TCP的加强，这种强化是在应用层上实现的
      - 它需要在该应用程序的客户端和服务器端包括SSL代码
      - SSL有它自己的套接字API,这类似于传统的TCP套接字API

#### UDP 服务

- UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务
- UDP是无连接的
  - 因此在两个进程通信前没有握手过程
- UDP协议提供一种不可靠数据传送服务
  - UDP协议并不保证该报文将到达接收进程
  - 到达接收进程的报文也可能是乱序到达的
- UDP没有包括拥塞控制机制

#### 因特网运输协议所不能提供的服务

- 吞吐量或定时保证, 这些服务目前的因特网运输协议并没有提供
  - 时间敏感应用已经被设计成尽最大可能对付这种保证的缺乏, 因此这些应用经常工作得相当好
  - 今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证

- 流行的因特网应用及其应用层协议和支撑的运输协议

| 应用     | 应用层协议                                       | 支撑的运输协议   |
|--------|---------------------------------------------|-----------|
| 电子邮件   | SMTP [RFC 5321]                             | TCP       |
| 远程终端访问 | Telnet [RFC 854]                            | TCP       |
| Web    | HTTP [RFC 2616]                             | TCP       |
| 文件传输   | FTP [ RFC 959]                              | TCP       |
| 流式多媒体  | HTTP (如 YouTube)                            | TCP       |
| 因特网电话  | SIP [RFC 3261]、RTP [ RFC 3550]或专用的(如 Skype) | UDP 或 TCP |

- 选择TCP的最主要原因是TCP提供了可靠数据传输服务，确保所有数据最终到达目的地
- 因特网电话应用（如Skype）通常能够容忍某些丢失但要求达到一定的最小速率才能有效工作
  - 所以因特网电话应用的开发者通常愿意将该应用运行在UDP上
    - 从而设法避开TCP的拥塞控制机制和分组开销
  - 但因为许多防火墙被配置成阻挡（大多数类型的）UDP流量
    - 所以因特网电话应用通常设计成如果UDP通信失败就使用TCP作为备份

### 2.1.5 应用层协议

- 应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了：
  - 交换的报文类型
    - 例如请求报文和响应报文。
  - 各种报文类型的语法
    - 如报文中的各个字段及这些字段是如何描述的。
  - 字段的语义
    - 即这些字段中包含的信息的含义。
  - 一个进程何时以及如何发送报文，对报文进行响应的规则

- 有些应用层协议是由RFC文档定义的，因此它们位于公共域中
- 还有很多别的应用层协议是专用的，有意不为公共域使用
  - Skype使用了专用的应用层协议

#### 本书涉及的网络应用

- Web
- 文件传输
- 电子邮件
- 目录服务
- 流式视频
- P2P

## 2.2 Web 和 HTTP

- 万维网（WorldWideWeb）, 极大地改变了人们与工作环境内外交流的方式
  - 它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网

- Web 的按需操作
  - 当用户需要时，就能得到所想要的内容
- 表单、Java小程序和很多其他的装置，使我们可以与Web页面和站点进行交互

### 2.2.1 HTTP 概况

- Web的应用层协议是**超文本传输协议**（HyperText Transfer Protocol, HTTP）
  - 它是 Web 的核心，在［RFC 1945］和［RFC 2616］中进行了定义

- HTTP由两个程序实现：一个客户程序和一个服务器程序
  - 客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话
  - HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式

- **Web页面**（Webpage）（也叫文档）是由对象组成的
  - 一个**对象**（object）只是一个文件
    - 诸如一个HTML文件、一个JPEG图形、一个Java小程序或一个视频片段这样的文件
    - 它们可通过一个URL地址寻址
    - 多数Web页面含有一个**HTML基本文件**（base HTML file）以及几个引用对象
  - 每个URL地址由两部分组成
    - 存放对象的服务器主机名
    - 对象的路径名

- **Web浏览器**（Web browser）是实现了HTTP的客户端
  - 所以在Web环境中经常交替使用“浏览器”和“客户”这两个术语
- **Web服务器**（Webserver）是实现了 HTTP的服务器端
  - 用于存储Web对象，每个对象由 URL 寻址

- HTTP
  - HTTP定义了Web客户向Web服务器请求 Web页面的方式，以及服务器向客户传送Web 页面的方式
  - ![HTTP 的请求响应行为](images/2020-07-18-15-50-54.png)
    - 当用户请求一个Web页面时
      - 浏览器向服务器发出对该页面中所包含对象的HTTP请求报文
      - 服务器接收到请求并用包含这些对象的HTTP响应报文进行响应

  - HTTP使用TCP作为它的支撑运输协议
    - 客户端的套接字接口是客户进程与TCP连接之间的门
      - 客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文
    - 在服务器端的套接字接口则是服务器进程与TCP连接之间的门
      - 服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文

  - 因为HTTP服务器并不保存关于客户的任何信息，所以我们HTTP是一个**无状态协议**（stateless protocol）

### 2.2.2 非持续性连接和持续连接

- 客户发出一系列请求并且服务器对每个请求进行响应
  - **非持续连接**（non-persistent connection）
    - 每个请求/响应对是经一个单独的TCP连接发
  - **持续连接**（persistent connection）
    - 所有的请求及其响应经相同的TCP连接发送

- HTTP 既能够使用非持续连接，也能够使用持续连接
  - HTTP在其默认方式下使用持续连接

#### 采用非持续连接的HTTP

- 每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来
- 在默认方式下，大部分浏览器打开5~10个并行的TCP连接

- **往返时间**（Round-Trip Time, RTT）
  - 该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间
  - ![请求并接收一个 HTML 文件的时间估算](images/2020-07-18-16-06-36.png)
  - 两个 RTT 的使用分配 
    - 浏览器在它和Web服务器之间发起一个TCP连接
      - 这涉及一次“三次握手”过程
        - 即客户向服务器发送一个小TCP报文段
        - 服务器用一个小TCP报文段做出确认和响应
        - 最后，客户向服 务器返回确认
      - 三次握手中前两个部分所耗费的时间占用了一个RTT
    - 完成了三次握手的前两个部分后，客户结合三次握手的第三部分（确认）向该TCP连接发送一个HTTP请求报文
      - 一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件
      - 该HTTP 请求/响应用去了另一个RTT
  - 粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间

#### 采用持续连接的HTTP

- 非持续连接有一些缺点
  - 必须为每一个请求的对象建立和维护一个全新的连接
    - 对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量,
    - 这给Web服务器带来了严重的负担
  - 每一个对象经受两倍RTT的交付时延, 即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象

- 在采用 HTTP1.1 持续连接的情况下，服务器在发送响应后保持该TCP连接打开
  - 在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送
  - 特别是，一个完整的 Web页面可以用单个持续TCP连接进行传送
  - 如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接

### 2.2.3 HTTP 报文格式

- HTTP规范［RFC 1945； RFC 2616］包含了对HTTP报文格式的定义
  - HTTP报文有两种：请求报文和响应报文

#### HTTP 请求报文

- 典型的HTTP请求报文

  ```html
  GET /somedir/page.html HTTP/1.1
  Host: www.someschool.edu
  Connection: close
  User-agent: Mozilla/5.0
  Accept-language: fr

  ```

  - 最后一行后再附加一个回车换行符
  - HTTP请求报文的第一行叫做请求行（request line）,其后继的行叫做首部行（header line）
  - 请求行有3个字段：
    - 方法字段
      - 可以取几种不同的值
        - 包括GET、POST、HEAD、PUT和DELETE
        - HEAD方法类似于GET方法
          - 当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象
          - 应用程序开发者常用HEAD方法进行调试跟踪
        - PUT方法常与Web发行工具联合使用，它允许用户上传对象到指定的Web服务器上指定的路径（目录）
        - DELETE方法允许用户或者应用程序删除Web服务器上的对象
    - URL字段
    - HTTP版本字段
  - 首部行
    - Host 指明了对象所在的主机
      - 其提供的信息是Web代理高速缓存所要求的
    - 通过包含Connection： close首部行，该浏览器告诉服务器不希望麻烦地使用持续连接
    - User-agent：首部行用来指明用户代理
      - 即向服务器发送请求的浏览器的类型
      - 服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本
    - Accept-language： 首部行表示用户想得到该对象的法语版本（如果服务器中有这样的对象的话）
      - 否则，服务器应当发送它的默认版本

- 请求报文的通用格式
  - ![HTTP 请求报文的通用格式](images/2020-07-18-16-24-25.png)
  - 在首部行（和附加的回车和换行）后有一个“实体体”（entity body）
    - 使用GET方法时实体体为空，而使用 POST方法时才使用该实体体

#### HTTP 响应报文

- 典型的响应报文

```html
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)
```

- ![HTTP 请求报文的通用格式](images/2020-07-19-15-56-48.png)

- 响应报文主要有三个部分
  - 初始状态行(status line)
    - 状态码及其相应的短语指示了请求的结果
    - 一些常见的状态码和相关的短语包括：
      - 200 0K
        - 请求成功，信息在返回的响应报文中。
      - 301 Moved Permanently
        - 请求的对象已经被永久转移了
        - 新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。
        - 400 Bad Request
          - 一个通用差错代码，指示该请求不能被服务器理解
        - 404 Not Found
          - 被请求的文档不在服务器上
        - 505 HTTP Version Not Supported
          - 服务器不支持请求报文使用的HTTP协议版本。
  - 首部行(headerline)
    - 服务器用Connection： close首部行告诉客户，发送完报文后将关闭该TCP连接
    - Date：首部行指示服务器产生并发送该响应报文的日期和时间
      - 这个时间不是指对象创建或者最后修改的时间
      - 而是服务器从它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间
      - Server：首部行指示该报文是由一台Apache Web服务器产生的
      - Last-Modified：首部行指示了对象创建或者最后修改的日期和时间
        - 此行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要
      - Content-Length：首部行指示了被发送对象中的字节数
      - Content-Type：首部行指示了实体体中的对象是HTML文本
  - 实体体(entity body)
    - 实体体部分是报文的主要部分，它包含了所请求的对象本身

### 2.2.4 用户与服务器进行交互：cookie

- HTTP服务器是无状态的
- 然而一个Web站点通常希望能够识别用户
  - 可能是因为服务器希望限制用户的访问
  - 或者因为它希望把内容与用户身份联系起来
- 为此，HTTP使用了 cookie
  - cookie在［RFC 6265］中定义，它允许站点对用户进行跟踪

- ![用cookie跟踪用户状态](images/2020-07-19-15-57-44.png)
- cookie技术有4个组件
  - 在HTTP响应报文中的一个cookie首部行
    - 类似于

      ```html
      Set-cookie: 1678
      ```

  - 在HTTP请求报文中的一个cookie首部行
    - 每请求一个Web页面，浏览器就会从本地cookie文件中获取她对这个网站的识别码，并放到HTTP请求报文中包括识别 码的cookie首部行中
    - 类似于

      ```html
      Cookie: 1678
      ```

  - 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理
    - 当浏览器收到了该HTTP响应报文时，该浏览器在它管理的特定cookie文件中添加一行
      - 该行包含服务器的主机名和在Set-cookie： 首部中的识别码
  - 位于Web站点的一个后端数据库
    - 利用 Cookie，服务器可以跟踪特定用户在当前站点的活动

- cookie可以用于标识一个用户
  - cookie可以在无状态的HTTP之上建立一个用户会话层

### 2.2.5 Web 缓存


